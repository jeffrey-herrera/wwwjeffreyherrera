---
import type { Project, Playlist, Playground } from '../sanity/types'
import SanityImage from './SanityImage.astro'
import { urlFor } from '../sanity/image'

interface Props {
  item: Project | Playlist | Playground
  type: 'project' | 'playlist' | 'playground'
  class?: string
}

const { item, type, class: className = '' } = Astro.props

function getItemImage(item: Project | Playlist | Playground) {
  switch (type) {
    case 'project':
      return (item as Project).image
    case 'playlist':
      return (item as Playlist).coverArt
    case 'playground':
      return (item as Playground).image
    default:
      return null
  }
}

function getItemTitle(item: Project | Playlist | Playground): string {
  switch (type) {
    case 'project':
    case 'playground':
      return (item as Project | Playground).title
    case 'playlist':
      return (item as Playlist).name
    default:
      return 'Untitled'
  }
}

function getItemMeta(item: Project | Playlist | Playground): string {
  switch (type) {
    case 'project':
      const project = item as Project
      return `${project.category} • ${project.year}`
    case 'playlist':
      const playlist = item as Playlist
      return `${playlist.month} ${playlist.year}`
    case 'playground':
      const playground = item as Playground
      return `${playground.type} • ${new Date(playground.publishedAt).getFullYear()}`
    default:
      return ''
  }
}

function getItemDescription(item: Project | Playlist | Playground): string {
  switch (type) {
    case 'project':
    case 'playground':
      return (item as Project | Playground).description || ''
    case 'playlist':
      return (item as Playlist).featuredTrack || ''
    default:
      return ''
  }
}

function getItemUrl(item: Project | Playlist | Playground): string {
  switch (type) {
    case 'project':
      return `/work/${(item as Project).slug.current}`
    case 'playlist':
      return (item as Playlist).spotifyUrl
    case 'playground':
      return `/playground/${(item as Playground).slug.current}`
    default:
      return '#'
  }
}

const image = getItemImage(item)
const imageUrl = image ? urlFor(image).width(400).height(400).url() : null
---

<article 
  class={`dynamic-color-card relative overflow-hidden rounded-xl transition-all duration-500 ${className}`}
  data-item-id={item._id}
  data-item-type={type}
  data-image-url={imageUrl}
>
  <!-- Background with dynamic gradient -->
  <div class="absolute inset-0 bg-gradient-to-br from-theme-dominant/20 to-theme-secondary/10"></div>
  
  <!-- Content -->
  <div class="relative z-10 p-6">
    <header class="mb-4">
      <div class="flex items-center gap-3 mb-2">
        <span class="px-2 py-1 bg-theme-accent/20 text-theme-accent text-xs font-medium rounded-full">
          {type}
        </span>
        {item.featured && (
          <span class="px-2 py-1 bg-theme-dominant/20 text-theme-dominant text-xs font-medium rounded-full">
            ★ Featured
          </span>
        )}
      </div>
      
      <h3 class="text-xl font-serif text-theme-text mb-1">
        {getItemTitle(item)}
      </h3>
      
      <p class="text-sm text-theme-muted">
        {getItemMeta(item)}
      </p>
    </header>

    {image && (
      <div class="mb-4 aspect-video bg-theme-background/50 rounded-lg overflow-hidden">
        <SanityImage 
          source={image} 
          alt={getItemTitle(item)}
          variant="medium"
          class="w-full h-full object-cover crossfade-image"
        />
      </div>
    )}

    <p class="text-theme-text/80 text-sm mb-4 line-clamp-2">
      {getItemDescription(item)}
    </p>

    <footer class="flex items-center justify-between">
      <a 
        href={getItemUrl(item)}
        target={type === 'playlist' ? '_blank' : '_self'}
        rel={type === 'playlist' ? 'noopener noreferrer' : undefined}
        class="inline-flex items-center gap-2 px-4 py-2 bg-theme-dominant hover:bg-theme-accent text-white text-sm rounded-lg transition-colors duration-300"
      >
        <span>{type === 'playlist' ? 'Listen' : 'View'}</span>
        <span>{type === 'playlist' ? '♪' : '→'}</span>
      </a>
      
      <div class="flex items-center gap-1">
        <div class="w-3 h-3 bg-theme-dominant rounded-full"></div>
        <div class="w-3 h-3 bg-theme-secondary rounded-full"></div>
        <div class="w-3 h-3 bg-theme-accent rounded-full"></div>
      </div>
    </footer>
  </div>

  <!-- Hover overlay -->
  <div class="absolute inset-0 bg-theme-dominant/5 opacity-0 hover:opacity-100 transition-opacity duration-300 pointer-events-none"></div>
</article>

<style>
  .dynamic-color-card {
    /* Default theme colors (fallbacks) */
    --theme-dominant: #f97316;
    --theme-secondary: #64748b;
    --theme-accent: #06b6d4;
    --theme-text: #1a1a1a;
    --theme-background: #ffffff;
    --theme-muted: #6b7280;
    
    /* Dynamic theming will override these */
    background: var(--theme-background);
    border: 1px solid var(--theme-muted, #e5e7eb);
    box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
  }

  .dynamic-color-card:hover {
    transform: translateY(-2px);
    box-shadow: 0 10px 15px -3px var(--theme-dominant, #f97316)20;
  }

  .line-clamp-2 {
    display: -webkit-box;
    -webkit-line-clamp: 2;
    -webkit-box-orient: vertical;
    overflow: hidden;
  }

  .crossfade-image {
    transition: all 0.3s ease;
  }

  .dynamic-color-card:hover .crossfade-image {
    filter: saturate(1.2) brightness(1.1);
  }
</style>

<script>
  import { extractImageColors, applyPaletteToElement, createThemeClass } from '../utils/colorExtraction'

  class DynamicColorManager {
    private processedCards = new Set<string>()

    constructor() {
      this.initializeCards()
    }

    private async initializeCards(): Promise<void> {
      const cards = document.querySelectorAll('.dynamic-color-card') as NodeListOf<HTMLElement>
      
      // Process cards with a slight delay to avoid blocking
      for (let i = 0; i < cards.length; i++) {
        setTimeout(() => {
          this.processCard(cards[i])
        }, i * 100) // Stagger processing
      }
    }

    private async processCard(card: HTMLElement): Promise<void> {
      const itemId = card.dataset.itemId
      if (!itemId || this.processedCards.has(itemId)) return

      this.processedCards.add(itemId)

      try {
        const imageUrl = card.dataset.imageUrl
        if (!imageUrl) return

        // Create image element for color extraction
        const img = new Image()
        img.crossOrigin = 'anonymous'
        
        img.onload = async () => {
          try {
            const palette = await extractImageColors(img)
            
            // Apply palette to card
            applyPaletteToElement(card, palette)
            
            // Add theme class for additional styling
            const themeClass = createThemeClass(palette)
            card.classList.add(themeClass)
            
            // Add a subtle animation when colors are applied
            card.style.transition = 'all 0.5s ease'
            card.style.opacity = '0.8'
            setTimeout(() => {
              card.style.opacity = '1'
            }, 50)

            // Track color extraction for analytics
            if (window.trackContentInteraction) {
              window.trackContentInteraction(
                card.dataset.itemType as any, 
                itemId, 
                'Color extraction',
                'interact'
              )
            }
          } catch (error) {
            console.warn('Failed to extract colors for card:', itemId, error)
          }
        }

        img.onerror = () => {
          console.warn('Failed to load image for color extraction:', imageUrl)
        }

        img.src = imageUrl
      } catch (error) {
        console.warn('Error processing card colors:', error)
      }
    }
  }

  // Initialize when DOM is ready
  document.addEventListener('DOMContentLoaded', () => {
    new DynamicColorManager()
  })

  // Re-initialize on page navigation (for SPA-like behavior)
  document.addEventListener('astro:page-load', () => {
    new DynamicColorManager()
  })
</script>